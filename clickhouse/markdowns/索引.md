## clickhouse 索引和排序

> https://developer.aliyun.com/article/780402

---

### 排序键优化

```shell
CREATE TABLE order_info
(
    `oid`   UInt64,                     --订单ID
    `buyer_nick`    String,     --买家ID
    `seller_nick`   String,     --店铺ID
    `payment`   Decimal64(4), --订单金额
    `order_status`  UInt8,         --订单状态
    ...
    `gmt_order_create`  DateTime, --下单时间
    `gmt_order_pay` DateTime,         --付款时间
    `gmt_update_time` DateTime,     --记录变更时间
    INDEX oid_idx (oid) TYPE minmax GRANULARITY 32
)
ENGINE = MergeTree()
PARTITION BY toYYYYMMDD(gmt_order_create)         --以天为单位分区
ORDER BY (seller_nick, gmt_order_create, oid) --排序键
PRIMARY KEY (seller_nick, gmt_order_create)     --主键
SETTINGS index_granularity = 8192;
```

特点：
- 基于pk和index_granularity，每间隔index_granularity抽出一层索引来构建跳表数组，保存主键字段，例子中的seller_nick, gmt_order_create两个前缀列。
- 查询性能主要就是靠ClickHouse牛逼的数据并行扫描能力和高效的列式计算引擎在硬抗，不应该用mysql方式创建索引。
- 索引字段的选择，离散度或者区分度不应太大，也不能太小。当离散度过大时，调表加速作用会减弱。

### 分区键优化-MinMax裁剪

i.e:

当"跳跃数组"中相邻的两个元组是('a', 1)和('a', 10086)时，我们可以推断出第二列在对应的行号区间内值域是[1, 10086]；若相邻的元素是('a', 1)和('b', 10086)，则第二列的值域范围就变成(-inf, +inf)了，无法依据第二列的过滤条件进行跳过。

当主键索引的优化空间有限时，可以将数据按照分区分割来整合。

```
select count(*) 
from order_info where 
gmt_order_create > '2020-0802 00:00:00' 
and gmt_order_create < '2020-0804 15:00:00'
```

上述查询case中，优化器根据每个DataPart的gmt_order_create最大值最小值可以快速裁剪掉不相关的DataPart，这中裁剪方式对数据的筛选效率比排序键索引更高。

Partition by 可以整合多个字段。比如，把partition by定义成：
(toYYYYMMDD(gmt_order_create), (gmt_order_pay - gmt_order_create)/3600/240)
这样一来DataPart在gmt_order_create和gmt_order_pay两列上就都有了MinMax裁剪索引。

特点：
- Partition by 的粒度要控制，如果太小的话，否则会使得datapart膨胀
- order by的不要重复放到partition by里，一般来说时间列更适合放在partition by上

### Skipping index优化-MetaScan

```
select *
from order_info where 
gmt_order_create > '2020-0802 00:00:00' 
and gmt_order_create < '2020-0807 00:00:00'
and oid = 726495;
```
INDEX oid_idx (oid) TYPE minmax GRANULARITY 32 这个索引定义为例，它会对oid列的每32个列存块做一个minmax值统计，统计结果存放在单独的索引文件里。有了索引后，数据扫描的逻辑变成了先扫描oid索引文件，检查oid的minmax区间是否覆盖目标值，后续扫描主表的时候可以跳过不相关的Block，这其实就是在OLAP里常用的Block Meta Scan技术。

特点：
- skipping index对查询的加速效果是一个常数级别的，索引扫描的时间是和数据量成正比的。

### Prewhere优化-两阶段扫描

在OLAP场景下最难搞定的问题就是满足查询条件的数据没有任何"局部性"。有局部性的数据可以借助以上三种方法优化。Prewhere 使用两家段扫描，优先扫描筛选率高的列进行过滤，再按需扫描其他列的块。

```
--常规
select *
from order_info where
where order_status = 2 --订单取消
and gmt_order_create > '2020-0802 00:00:00' 
and gmt_order_create < '2020-0807 00:00:00'；
--两阶段扫描
select *
from order_info where
prewhere order_status = 2 --订单取消
where gmt_order_create > '2020-0802 00:00:00' 
and gmt_order_create < '2020-0807 00:00:00'；
```

特点：
- prewhere进行两阶段扫描，它的IO放大问题也依旧是非常明显的

### zorder技术

> https://mp.weixin.qq.com/s/pH2OArsHYIr9cmP3lLR4lw

Z-ORDER这个特性是为了解决用户对同一张表有不同维度的过滤查询请求。比如说我们有两个字段a和b，如果在建ClickHouse表的时候，我们ORDER BY  a,b.那么当a的基数很大的时候，用b去做过滤查询是没有效果的。

使用Z-Order顺序后，无论以A作为查询条件还是以B作为查询条件，都只能跳过50%的数据。但是在满足查询满足最左原则的情况下，由于Z-Order将原本自然顺序下有序的数据变得无序了，因此反而降低了满足最左原则下的查询效率。这种现象在小数据的情况下不明显，但是当数据量增加时，这种现象带来的影响会越来越大。

master 分支没找到相关代码。

### 物化视图

#### 正常视图

正常的视图不会存储任何数据。也就是存储了sql语句。

```
CREATE [OR REPLACE] VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER] AS SELECT ...
```

#### 物化视图

物化视图会watch select的表单，并且更新视图。

Clickhouse中实现的物化视图更像是插入触发器。如果查询中有一些聚合，则仅应用于新插入的数据。源表现有数据的任何更改（例如更新，删除，删除分区等）不会更改实现的视图。

###  Projection (>= clickhouse version 21.7)

> https://xie.infoq.cn/article/f5ef2cfb9cd41bd817f5d1075
  https://jishuin.proginn.com/p/763bfbd66127

Projection 可以看成是对物化视图的增强，支持ddl，agg等特性，保证一致性。

物化视图虽然效果显著，但是却不够智能。物化视图本质上一张独立的表，通过原表的触发器，实时的向视图表写入数据。

既然物化视图也是独立的表，那么自然就会存在与原表数据一致性的问题。如果物化视图很多，维护起来也是一个问题。

Projection 意指一组列的组合，可以按照与原表不同的排序存储，并且支持聚合函数的查询。

多个 projection 在 part 目录下以多个子目录存储，projection 目录下存储基于原始数据聚合的数据。所以，projection 写入与原始数据写入同步，只有创建 projection 之后写入的数据才会被物化，保证数据的一致性。

```
CREATE TABLE event_projection1 
( 
    `event_key` String, 
    `user` UInt32, 
    `event_time` DateTime64(3, 'Asia/Shanghai'), 
    `dim1` String, 
    `dim2` String, 
    `dim3` String, 
    PROJECTION p1 
    ( 
        SELECT 
            groupBitmap(user), 
            count(1) 
        GROUP BY dim1 
    ) 
) 
ENGINE = MergeTree() 
ORDER BY (event_key, user, event_time) 
```

或者：

```
ALTER TABLE event_projection1 
    ADD PROJECTION p2 
    ( 
        SELECT 
            count(1), 
            groupBitmap(user) 
        GROUP BY dim1, dim3 
    ) 
```

特点：
- 命中 projection 相比没有命中 projection 对于查询性能的提升非常明显。
- 构建 projection 对于存储，数据插入有一定的额外开销。
- 如果构建 projection 的时候混入了高基维度，查询耗时相比没有混入高基维度，查询性能同比降低了近 200 倍，存储与插入时间也付出了更多的额外开销。

### 二级索引

> 当满足搜索条件的记录数比列存块小一个数量级时(筛选率超过100000:1)，二级索引才能发挥比较明显的性能优势。

#### 常规索引

```
CREATE TABLE index_test 
(
  id UInt64, 
  d DateTime, 
  x UInt64,
  y UInt64, 
  tag String,
  KEY tag_idx tag TYPE range, --单列索引
  KEY d_idx toStartOfHour(d) TYPE range, --表达式索引
  KEY combo_idx (toStartOfHour(d)，x, y) TYPE range, --多列联合索引
) ENGINE = MergeTree() ORDER BY id;
```

ddl:
```
--删除索引定义
Alter table index_test DROP KEY tag_idx;
--增加索引定义
Alter table index_test ADD KEY tag_idx tag TYPE range;
--清除数据分区下的索引文件
Alter table index_test CLEAR KEY tag_idx tag in partition partition_expr;
--重新构建数据分区下的索引文件
Alter table index_test MATERIALIZE KEY tag_idx tag in partition partition_expr;
```

支持多列索引的目的是减少特定查询pattern下的索引结果归并，针对QPS要求特别高的查询用户可以创建针对性的多列索引达到极致的检索性能。值得注意的是，用户对表达式构建索引后，原列上的查询条件也可以正常下推索引，不需要特意改写查询。同样用户对原列构建索引，过滤条件上对原列加了表达式的情况下，优化器也都可以正常下推索引。

### 多值索引(数组字段)

```
CREATE TABLE index_test 
(
  id UInt64, 
  tags Array(String),
  KEY tag_idx tag TYPE array --多值索引
) ENGINE = MergeTree() ORDER BY id;
--包含单个标签
select * from index_test where has(tags, 'aaa');
--包含所有标签
select * from index_test where hasAll(tags, ['aaa', 'bbb']);
--包含任意标签
select * from index_test where has(tags, ['aaa', 'ccc']);
```

### 字典索引(map)

```
CREATE TABLE index_test 
(
  id UInt64, 
  keys Array(String),
  vals Array(UInt32),
  KEY kv_idx (keys, vals) TYPE map --字典索引
) ENGINE = MergeTree() ORDER BY id;
--指定key的value等值条件 map['aaa'] = 32
select * from index_test where hasPairEQ(keys, vals, ('aaa', 32));
--指定key的value大于条件 map['aaa'] > 32
select * from index_test where hasPairGT(keys, vals, ('aaa', 32));
--指定key的value大于等于条件 map['aaa'] >= 32
select * from index_test where hasPairGTE(keys, vals, ('aaa', 32));
--指定key的value小于条件 map['aaa'] < 32
select * from index_test where hasPairLT(keys, vals, ('aaa', 32));
--指定key的value小于等于条件 map['aaa'] <= 32
select * from index_test where hasPairLTE(keys, vals, ('aaa', 32));
```
